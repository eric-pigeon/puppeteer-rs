var fs = require('fs');
var Handlebars = require("handlebars");
const { exec } = require("child_process");

const jsProtocol = require('devtools-protocol/json/js_protocol.json');
const browserProtocol = require('devtools-protocol/json/browser_protocol.json');
const protocolDomains = jsProtocol.domains.concat(browserProtocol.domains);
const modSource = fs.readFileSync("./mod.hbs", {encoding:'utf8', flag:'r'});
const modTemplate = Handlebars.compile(modSource);
const domainSource = fs.readFileSync("./domain.hbs", {encoding:'utf8', flag:'r'});
const domainTemplate = Handlebars.compile(domainSource);
// TODO skip some domains like DOMSnapshot because there's an array type that
// I don't know how to handle in rust quite yet
const domainsToSkip = ['DOMSnapshot', 'LayerTree', 'DOMStorage'];
const filteredProtocolDomains = protocolDomains.filter(domain => {
  return !domainsToSkip.includes(domain.domain);
});

Handlebars.registerHelper('autoGeneratedComment', () => {
 return "// This file is auto-generated do not edit manually.";
});

Handlebars.registerHelper('ufirst', (str) => {
  if (typeof str !== 'string') return '';
  return str.charAt(0).toUpperCase() + str.slice(1);
});

const rustType = (jsType, ref, optional, isArray) => {
  var type = '';
  if (ref) {
    parts = ref.split('.');
    if (parts.length == 1) {
      type = parts[0];
    }
    else {
      type = "super::" + underscore(parts[0]) + "::" + parts[1];
    }
  }
  else {
    switch(jsType) {
      case 'string':
        type = "String";
        break;
      case 'object':
        type = "serde_json::map::Map<String, serde_json::Value>";
        break;
      case 'number':
        type = "f64";
        break;
      case 'integer':
        type = "i32";
        break;
      case 'boolean':
        type = "bool";
        break;
      case 'any':
        type = "serde_json::Value";
        break;
      default:
        console.log(jsType);
        process.exit(1);
    }
  }
  if (isArray) {
    type = "Vec<" + type + ">";
  }
  if (optional) {
    type = "Option<" + type + ">";
  }
  return type;
}
Handlebars.registerHelper('rustType', rustType);

Handlebars.registerHelper('switch', function(value, options) {
  this.switch_value = value;
  this.switch_break = false;
  return options.fn(this);
});

Handlebars.registerHelper('case', function(value, options) {
  if (value == this.switch_value) {
    this.switch_break = true;
    return options.fn(this);
  }
});

Handlebars.registerHelper('default', function(value, _options) {
  if (this.switch_break == false) {
    return value.fn(this);
  }
});

Handlebars.registerHelper('concat', (...args) => {
  args.pop();
  return args.join("");
});

const underscore = (str) => {
  if(str && typeof str === "string") {
    str = str.replaceAll(/::/g, '/');
    str = str.replaceAll(/([A-Z]+)([A-Z][a-z])/g,'$1_$2');
    str = str.replaceAll(/([a-z\d])([A-Z])/g,'$1_$2');
    str = str.replaceAll("-", "_");
    return str.toLowerCase();
  }
  return '';
};
Handlebars.registerHelper('underscore', underscore);

const camelize = str => {
  return str.replace(/(?:^\w|[A-Z]|\b\w)/g, function(word, _index) {
    return word.toUpperCase();
  }).replace(/[^a-zA-Z0-9]+/g, '');
}
Handlebars.registerHelper('camelize', camelize);

Handlebars.registerHelper('struct_key', str => {
  if (typeof str != 'string') return '';
  str = underscore(str);
  if (str == "type" || str == "override") {
    str = 'r#' + str;
  }
  return str;
});

Handlebars.registerHelper('eq', (a, b) => {
  return a == b;
});

Handlebars.registerHelper('ref', (type, parentType) => {
  parts = type.split('.');
  if (parts.length == 1) {
    if (type === parentType) {
      return "Box<" + parts[0] + ">";
    }
    return parts[0];
  }
  else {
    return "super::" + underscore(parts[0]) + "::" + parts[1];
  }
});

Handlebars.registerHelper("comment", str => {
  return str.split("\n").join("\n\/\/ ");
});

Handlebars.registerHelper('domainTypePartial', (typeObject) => {
  switch(typeObject.type) {
    case 'string':
      if (typeObject.enum != undefined) {
        return "enumType";
      }
      else {
        return "stringType";
      }
    case 'object':
      if (typeObject.properties === undefined) {
        return 'objectAnyType';
      }
      else {
        return "objectType";
      }
    case 'array':
      return "arrayType";
    case 'number':
      return 'numberType';
    case 'integer':
      return 'integerType';
    case 'boolean':
      return 'booleanType';
    default:
      console.log(typeObject);
      process.exit(1);
  }
});

Handlebars.registerHelper('propertyTypePartial', (propertyTypeObject) => {
  if (propertyTypeObject['$ref']) {
    return 'refProperty';
  }
  switch(propertyTypeObject.type) {
    case 'string':
      return "stringProperty";
      // TODO does it make sense to create enum types for theres
      // if (propertyTypeObject.enum != undefined) {
      //   return "enumProperty";
      // }
      // else {
      //   return "stringProperty";
      // }
    case 'object':
      return "objectProperty";
    case 'array':
      return "arrayProperty";
    case 'number':
      return 'numberProperty';
    case 'integer':
      return 'integerProperty';
    case 'boolean':
      return 'booleanProperty';
    case 'any':
      return 'anyProperty';
    default:
      console.log(propertyTypeObject);
      process.exit(1);
  }
});

Handlebars.registerPartial({
  // domain types
  'enumType': fs.readFileSync("./templates/enumType.hbs", {encoding:'utf8', flag:'r'}),
  'stringType': fs.readFileSync("./templates/stringType.hbs", {encoding:'utf8', flag:'r'}),
  'objectType': fs.readFileSync("./templates/objectType.hbs", {encoding:'utf8', flag:'r'}),
  'objectAnyType': fs.readFileSync("./templates/objectAnyType.hbs", {encoding:'utf8', flag:'r'}),
  'arrayType': fs.readFileSync("./templates/arrayType.hbs", {encoding:'utf8', flag:'r'}),
  'numberType': fs.readFileSync("./templates/numberType.hbs", {encoding:'utf8', flag:'r'}),
  'integerType': fs.readFileSync("./templates/integerType.hbs", {encoding:'utf8', flag:'r'}),
  'booleanType': fs.readFileSync("./templates/booleanType.hbs", {encoding:'utf8', flag:'r'}),

  // property types
  'enumProperty': fs.readFileSync("./templates/enumProperty.hbs", {encoding:'utf8', flag:'r'}),
  'stringProperty': fs.readFileSync("./templates/stringProperty.hbs", {encoding:'utf8', flag:'r'}),
  'objectProperty': fs.readFileSync("./templates/objectProperty.hbs", {encoding:'utf8', flag:'r'}),
  'arrayProperty': fs.readFileSync("./templates/arrayProperty.hbs", {encoding:'utf8', flag:'r'}),
  'numberProperty': fs.readFileSync("./templates/numberProperty.hbs", {encoding:'utf8', flag:'r'}),
  'integerProperty': fs.readFileSync("./templates/integerProperty.hbs", {encoding:'utf8', flag:'r'}),
  'booleanProperty': fs.readFileSync("./templates/booleanProperty.hbs", {encoding:'utf8', flag:'r'}),
  'refProperty': fs.readFileSync("./templates/refProperty.hbs", {encoding:'utf8', flag:'r'}),
  'anyProperty': fs.readFileSync("./templates/anyProperty.hbs", {encoding:'utf8', flag:'r'}),
});

(() => {
  fs.mkdir("../src/protocol/", {recursive: true}, (err) => {
    if (err) {
      console.log(err);
      process.exit(1);
    }
  });

  fs.writeFile("../src/protocol/mod.rs", modTemplate({"domains": filteredProtocolDomains}), (err) => {
    if (err) {
     console.log(err);
     process.exit(1);
    }
  });

  filteredProtocolDomains.forEach(domain => {
    enumTypes = {};
    (domain.types || []).forEach(domainType => {
      if (domainType.type !== "object" || domainType.properties === undefined ) { return; }

      var enumProperties = null;
      domainType.properties.forEach(property => {
        if (property.enum === undefined) { return; }
        if (enumProperties === null) { enumProperties = []; }
        enumProperties.push({
          name: property.name,
          enum: property.enum
        });
      });

      if (enumProperties !== null) {
        enumTypes[domainType.id] = enumProperties;
      }
    });

    commandEnumTypes = {};
    var addedEnumTypes = [];
    domain.commands.forEach(domainCommand => {
      if (domainCommand.parameters === undefined) { return; }
      var enumParameters = null;
      domainCommand.parameters.forEach(parameter => {
        if (parameter.enum === undefined) { return; }
        if (enumParameters === null) { enumParameters = []; }

        if (addedEnumTypes.find(enumType => enumType === parameter.name) === undefined) {
          addedEnumTypes.push(parameter.name);
          enumParameters.push({
            name: parameter.name,
            enum: parameter.enum
          });
        }
      });
      if (enumParameters !== null) {
        commandEnumTypes[domainCommand.name] = enumParameters;
      }
    });
    var renderedDomain = domainTemplate({
      "domain": domain,
      "enumTypes": enumTypes,
      "commandEnumTypes": commandEnumTypes
    });
    fs.writeFile("../src/protocol/" + underscore(domain.domain) + ".rs", renderedDomain, (err) => {
      if (err) {
        console.log(err);
        process.exit(1);
      }
    });
  });

  exec("cargo fmt");
})();
